/*
C64 Stream - CRT Visual Effects Shader
Copyright (C) 2025 Christian Gleissner

Licensed under the GNU General Public License v2.0 or later.
See <https://www.gnu.org/licenses/> for details.
*/

// Uniforms
uniform float4x4 ViewProj;
uniform texture2d image;

// CRT effect parameters
uniform bool scanlines_enable;
uniform float scanlines_opacity;
uniform int scanlines_width;
uniform float pixel_width;
uniform float pixel_height;
uniform bool bloom_enable;
uniform float bloom_strength;

sampler_state textureSampler {
    Filter   = Linear;
    AddressU = Clamp;
    AddressV = Clamp;
};

struct VertData {
    float4 pos : POSITION;
    float2 uv  : TEXCOORD0;
};

VertData VSDefault(VertData v_in)
{
    VertData vert_out;
    vert_out.pos = mul(float4(v_in.pos.xyz, 1.0), ViewProj);
    vert_out.uv  = v_in.uv;
    return vert_out;
}

float4 PSDefault(VertData v_in) : TARGET
{
    float2 uv = v_in.uv;
    
    // No longer apply pixel geometry scaling in shader - handled by matrix transform
    // Simply sample the texture at the given UV coordinates
    float4 color = image.Sample(textureSampler, uv);
    
    // Apply scanlines based on scaled canvas position
    if (scanlines_enable) {
        // Calculate the scaled canvas height
        float canvas_height = 272.0 * pixel_height; // Base height scaled by pixel_height
        
        // Get the position in the scaled canvas
        float scaled_row = uv.y * canvas_height;
        
        // Calculate which scanline row we're in
        // gap = scanlines_width, so each group has (1 + gap) rows
        float row_in_group = fmod(floor(scaled_row), float(scanlines_width) + 1.0);
        
        // Darken rows that are in the gap (not the first row of each group)
        if (row_in_group >= 1.0) {
            // Apply scanline opacity: 0 = complete black, 1 = copy of pixel row
            color.rgb *= scanlines_opacity;
        }
    }
    
    // Apply bloom effect - less aggressive, preserves color saturation
    if (bloom_enable) {
        float brightness = dot(color.rgb, float3(0.299, 0.587, 0.114));
        
        // Integrated threshold that decreases as strength increases
        // At strength=0, threshold is high (0.85), at strength=1, threshold is low (0.4)
        float threshold = 0.85 - (bloom_strength * 0.45);
        
        if (brightness > threshold) {
            // Calculate bloom factor based on how much we exceed threshold
            float bloom_factor = (brightness - threshold) / (1.0 - threshold);
            
            // Reduced multiplier (2.5x instead of 5x) for less aggressive bloom
            float bloom_intensity = bloom_factor * (bloom_strength * 2.5);
            
            // Preserve color saturation by not over-brightening
            // Mix between current color and slightly brightened color
            // This prevents washing out to white
            float3 bloom_color = color.rgb * (1.0 + bloom_intensity * 0.5);
            
            // Clamp to prevent over-saturation
            bloom_color = min(bloom_color, float3(1.0, 1.0, 1.0));
            
            // Blend with original color to preserve saturation
            color.rgb = lerp(color.rgb, bloom_color, bloom_intensity * 0.6);
        }
    }
    
    return color;
}

technique Draw
{
    pass
    {
        vertex_shader = VSDefault(v_in);
        pixel_shader  = PSDefault(v_in);
    }
}
