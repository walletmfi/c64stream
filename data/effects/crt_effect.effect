/*
C64 Stream - CRT Visual Effects Shader
Copyright (C) 2025 Christian Gleissner

Licensed under the GNU General Public License v2.0 or later.
See <https://www.gnu.org/licenses/> for details.
*/

// Platform detection for shader compilation
static const bool obs_glsl_compile = false; // DirectX 11 by default, overridden by OBS for OpenGL

// Uniforms
uniform float4x4 ViewProj;
uniform texture2d image;

// CRT effect parameters
uniform float scan_line_distance;      // Gap between scan lines as percentage of line height (0.0-2.0)
uniform float scan_line_strength;      // Darkness of gaps (0.0=no effect, 1.0=completely black)
uniform float pixel_width;
uniform float pixel_height;
uniform float blur_strength;
uniform float bloom_strength;
uniform int afterglow_duration_ms;
uniform int afterglow_curve;
uniform int tint_mode;
uniform float tint_strength;
uniform float dt_ms;
uniform texture2d texture_accum_prev;
uniform float output_height; // Output resolution height for scanline calculation

sampler_state textureSampler {
    Filter   = Point;  // Use nearest neighbor for pixel-perfect scaling
    AddressU = Clamp;
    AddressV = Clamp;
    MinLOD   = 0.0;
    MaxLOD   = 0.0;
};

struct VertData {
    float4 pos : POSITION;
    float2 uv  : TEXCOORD0;
};

VertData VSDefault(VertData v_in)
{
    VertData vert_out;
    vert_out.pos = mul(float4(v_in.pos.xyz, 1.0), ViewProj);
    vert_out.uv  = v_in.uv;
    return vert_out;
}

float4 PSDefault(VertData v_in) : TARGET
{
    // Ensure UV coordinates are properly normalized (Windows DirectX fix)
    float2 uv = saturate(v_in.uv);

    // === PIXEL GEOMETRY WITH BLUR CONTROL ===
    // Pixel geometry scaling is handled by matrix transforms
    // Here we apply blur control for crisp vs soft scaling
    float4 color;
    if (blur_strength > 0.0f) {
        // Gaussian-style blur with multiple taps for soft scaling
        // Use precise float for DirectX 11 compatibility
        float blur_radius = blur_strength * 0.003f;

        // Clamp UV coordinates to prevent sampling outside texture bounds
        // This fixes garbled output on Windows DirectX 11
        float2 uv_center = uv;
        float2 uv_right = saturate(uv + float2(blur_radius, 0.0f));
        float2 uv_left = saturate(uv - float2(blur_radius, 0.0f));
        float2 uv_up = saturate(uv + float2(0.0f, blur_radius));
        float2 uv_down = saturate(uv - float2(0.0f, blur_radius));
        float2 uv_tr = saturate(uv + float2(blur_radius, blur_radius));
        float2 uv_bl = saturate(uv - float2(blur_radius, blur_radius));
        float2 uv_tl = saturate(uv + float2(-blur_radius, blur_radius));
        float2 uv_br = saturate(uv - float2(-blur_radius, blur_radius));

        // 9-tap gaussian-style sampling with clamped coordinates
        color  = image.Sample(textureSampler, uv_center) * 0.25f;  // Center (main weight)
        color += image.Sample(textureSampler, uv_right) * 0.125f;  // Right
        color += image.Sample(textureSampler, uv_left) * 0.125f;   // Left
        color += image.Sample(textureSampler, uv_up) * 0.125f;     // Up
        color += image.Sample(textureSampler, uv_down) * 0.125f;   // Down
        color += image.Sample(textureSampler, uv_tr) * 0.0625f;    // Top-right
        color += image.Sample(textureSampler, uv_bl) * 0.0625f;    // Bottom-left
        color += image.Sample(textureSampler, uv_tl) * 0.0625f;    // Top-left
        color += image.Sample(textureSampler, uv_br) * 0.0625f;    // Bottom-right
    } else {
        // Precise sampling for crisp scaling (no blur)
        color = image.Sample(textureSampler, uv);
    }

    // === SCANLINES EFFECT (CRT-ACCURATE ALTERNATING PATTERN) ===
    // scan_line_distance: height ratio of gap to scanline (0.0 = no gap, 0.5 = gap half as tall as scanline, 1.0 = gap same height as scanline)
    // scan_line_strength: darkness of the gap (0.0 = no darkness, 1.0 = completely black)
    if (scan_line_distance > 0.0f && scan_line_strength > 0.0f) {
        // Calculate which row we're in within the scaled output
        // Use precise float arithmetic for DirectX 11 compatibility
        float pixel_row = uv.y * max(output_height, 1.0f);

        // Match C code integer-based scaling for pixel-perfect scanlines
        // Map scanline distance to distinct scaling ratios with correct spacing patterns
        // This ensures crisp scanlines and gaps with no fractional scaling

        float total_pixels_per_unit;
        float scanline_pixels_per_unit;
        if (scan_line_distance <= 0.25f) {       // Tight: S1S1S1S1G1
            total_pixels_per_unit = 5.0f;
            scanline_pixels_per_unit = 4.0f;
        } else if (scan_line_distance <= 0.5f) { // Normal: S1S1G1
            total_pixels_per_unit = 3.0f;
            scanline_pixels_per_unit = 2.0f;
        } else if (scan_line_distance <= 1.0f) { // Wide: S1S1G1G1
            total_pixels_per_unit = 4.0f;
            scanline_pixels_per_unit = 2.0f;
        } else {                                 // Extra Wide: S1G1G1
            total_pixels_per_unit = 3.0f;
            scanline_pixels_per_unit = 1.0f;
        }

        // Use precise floor operation for DirectX 11
        float scanline_index = floor(pixel_row / total_pixels_per_unit);
        float position_in_scanline_unit = pixel_row - (scanline_index * total_pixels_per_unit);

        // Check if this pixel is in the scanline portion or gap portion
        // Add small epsilon for floating point precision on DirectX 11
        if (position_in_scanline_unit >= (scanline_pixels_per_unit - 0.001f)) {
            // This pixel is in the gap portion - darken it
            color.rgb = lerp(color.rgb, color.rgb * (1.0f - scan_line_strength), 1.0f);
        }
        // position_in_scanline_unit < scanline_pixels_per_unit: This pixel is the scanline itself (remains bright)
    }

    // === ENHANCED BLOOM EFFECT WITH BLEEDING ===
    if (bloom_strength > 0.0f) {
        // Sample current pixel and neighbors for bloom bleeding effect
        float4 center = color;
        float bloom_radius = bloom_strength * 0.002f; // Radius scales with strength

        // Multi-tap sampling for bloom bleeding - more taps = more bleeding at higher strength
        float4 bloom_sum = center * 0.4f; // Center weight

        // Cross pattern sampling (4 directions) with clamped UVs for DirectX 11
        bloom_sum += image.Sample(textureSampler, saturate(uv + float2(bloom_radius, 0.0f))) * 0.15f;
        bloom_sum += image.Sample(textureSampler, saturate(uv - float2(bloom_radius, 0.0f))) * 0.15f;
        bloom_sum += image.Sample(textureSampler, saturate(uv + float2(0.0f, bloom_radius))) * 0.15f;
        bloom_sum += image.Sample(textureSampler, saturate(uv - float2(0.0f, bloom_radius))) * 0.15f;

        // Diagonal sampling for stronger bloom effect
        if (bloom_strength > 0.3f) {
            float diagonal_factor = 0.7f;
            bloom_sum += image.Sample(textureSampler, saturate(uv + float2(bloom_radius, bloom_radius) * diagonal_factor)) * 0.05f;
            bloom_sum += image.Sample(textureSampler, saturate(uv + float2(-bloom_radius, bloom_radius) * diagonal_factor)) * 0.05f;
            bloom_sum += image.Sample(textureSampler, saturate(uv + float2(bloom_radius, -bloom_radius) * diagonal_factor)) * 0.05f;
            bloom_sum += image.Sample(textureSampler, saturate(uv + float2(-bloom_radius, -bloom_radius) * diagonal_factor)) * 0.05f;
        }

        // Use precise luminance calculation for DirectX 11
        float brightness = dot(bloom_sum.rgb, float3(0.299f, 0.587f, 0.114f));

        // Dynamic threshold that decreases as strength increases
        float threshold = 0.85f - (bloom_strength * 0.45f);

        if (brightness > threshold) {
            // Calculate bloom factor based on how much we exceed threshold
            float bloom_factor = (brightness - threshold) / max(1.0f - threshold, 0.001f); // Prevent division by zero

            // ENHANCED: 7.5x stronger bloom
            float bloom_intensity = bloom_factor * (bloom_strength * 7.5f);

            // Create bloom effect that preserves color saturation but bleeds
            float3 bloom_color = bloom_sum.rgb * (1.0f + bloom_intensity * 1.2f);

            // Allow more oversaturation for stronger glow effect
            bloom_color = min(bloom_color, float3(1.5f, 1.5f, 1.5f));

            // Blend with original color to create bleeding effect using saturate for DirectX 11
            color.rgb = lerp(center.rgb, bloom_color, saturate(bloom_intensity * 0.8f));
        } else {
            // Use the blended sample even without bloom for subtle bleeding
            color.rgb = lerp(center.rgb, bloom_sum.rgb, bloom_strength * 0.1f);
        }
    }

    // === AFTERGLOW EFFECT ===
    // Temporal afterglow - blend with previous frame to create phosphor persistence
    if (afterglow_duration_ms > 0) {
        // Sample the previous frame at the same UV coordinate with clamped UV for DirectX 11
        float4 prev_frame = texture_accum_prev.Sample(textureSampler, saturate(uv));

        // Calculate decay factor based on duration (frame-to-frame persistence)
        // Higher duration = slower decay = more persistent afterglow
        float decay_factor = 1.0f - (dt_ms / max(float(afterglow_duration_ms), 1.0f)); // Prevent division by zero
        decay_factor = saturate(decay_factor); // Use saturate for DirectX 11 compatibility
        decay_factor = min(decay_factor, 0.95f); // Clamp to prevent infinite persistence

        // Apply decay curve to modify the decay behavior
        if (afterglow_curve == 1) { // Gradual Fade (Slow Start)
            decay_factor = decay_factor * decay_factor; // Quadratic - slower initial fade
        }
        else if (afterglow_curve == 2) { // Rapid Fade (Fast Start)
            decay_factor = sqrt(abs(decay_factor)); // Square root - faster initial fade, abs for DirectX 11
        }
        else if (afterglow_curve == 3) { // Long Tail (Exponential)
            decay_factor = pow(abs(decay_factor), 0.5f); // More persistent tail, abs for DirectX 11
        }
        // Linear (0) uses decay_factor as-is

        // Blend previous frame with current frame
        // Only non-black pixels from previous frame should contribute to afterglow
        float prev_brightness = dot(prev_frame.rgb, float3(0.299f, 0.587f, 0.114f));
        if (prev_brightness > 0.01f) { // Threshold to avoid amplifying pure black
            // Mix the previous frame's color with current color
            // This creates true temporal persistence - red→blue becomes red→purple→blue
            color.rgb = max(color.rgb, prev_frame.rgb * decay_factor);
        }
    }

    // === SCREEN TINT EFFECT ===
    // Emulate 1980s monochrome CRTs: first convert to monochrome, then apply tint
    if (tint_mode > 0 && tint_strength > 0.0f) {
        // Step 1: Convert to monochrome (grayscale)
        float luminance = dot(color.rgb, float3(0.299f, 0.587f, 0.114f));
        float3 monochrome = float3(luminance, luminance, luminance);

        // Step 2: Apply tint to the monochrome image
        float3 tinted_color = color.rgb;

        if (tint_mode == 1) { // Amber CRT
            float3 amber_tint = float3(1.0f, 0.75f, 0.3f);
            tinted_color = lerp(color.rgb, monochrome * amber_tint, saturate(tint_strength));
        }
        else if (tint_mode == 2) { // Green CRT
            float3 green_tint = float3(0.5f, 0.95f, 0.35f);
            tinted_color = lerp(color.rgb, monochrome * green_tint, saturate(tint_strength));
        }
        else if (tint_mode == 3) { // Pure Monochrome
            tinted_color = lerp(color.rgb, monochrome, saturate(tint_strength));
        }
        // tint_mode == 0 (None) - no change

        color.rgb = tinted_color;
    }

    // Ensure final color is properly clamped for DirectX 11
    return saturate(color);
}

technique Draw
{
    pass
    {
        vertex_shader = VSDefault(v_in);
        pixel_shader  = PSDefault(v_in);
    }
}
