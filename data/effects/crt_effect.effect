/*
C64 Stream - CRT Visual Effects Shader
Copyright (C) 2025 Christian Gleissner

Licensed under the GNU General Public License v2.0 or later.
See <https://www.gnu.org/licenses/> for details.
*/

// Uniforms
uniform float4x4 ViewProj;
uniform texture2d image;

// CRT effect parameters
uniform float scan_line_distance;      // Gap between scan lines as percentage of line height (0.0-2.0)
uniform float scan_line_strength;      // Darkness of gaps (0.0=no effect, 1.0=completely black)
uniform float pixel_width;
uniform float pixel_height;
uniform float blur_strength;
uniform float bloom_strength;
uniform int afterglow_duration_ms;
uniform int afterglow_curve;
uniform int tint_mode;
uniform float tint_strength;
uniform float dt_ms;
uniform texture2d texture_accum_prev;
uniform float output_height; // Output resolution height for scanline calculation

sampler_state textureSampler {
    Filter   = Linear;
    AddressU = Clamp;
    AddressV = Clamp;
};

struct VertData {
    float4 pos : POSITION;
    float2 uv  : TEXCOORD0;
};

VertData VSDefault(VertData v_in)
{
    VertData vert_out;
    vert_out.pos = mul(float4(v_in.pos.xyz, 1.0), ViewProj);
    vert_out.uv  = v_in.uv;
    return vert_out;
}

float4 PSDefault(VertData v_in) : TARGET
{
    float2 uv = v_in.uv;

    // === PIXEL GEOMETRY WITH BLUR CONTROL ===
    // Pixel geometry scaling is handled by matrix transforms
    // Here we apply blur control for crisp vs soft scaling
    float4 color;
    if (blur_strength > 0.0) {
        // Gaussian-style blur with multiple taps for soft scaling
        float blur_radius = blur_strength * 0.003;

        // 9-tap gaussian-style sampling
        color  = image.Sample(textureSampler, uv) * 0.25;                                    // Center (main weight)
        color += image.Sample(textureSampler, uv + float2(blur_radius, 0.0)) * 0.125;       // Right
        color += image.Sample(textureSampler, uv - float2(blur_radius, 0.0)) * 0.125;       // Left
        color += image.Sample(textureSampler, uv + float2(0.0, blur_radius)) * 0.125;       // Up
        color += image.Sample(textureSampler, uv - float2(0.0, blur_radius)) * 0.125;       // Down
        color += image.Sample(textureSampler, uv + float2(blur_radius, blur_radius)) * 0.0625;   // Top-right
        color += image.Sample(textureSampler, uv - float2(blur_radius, blur_radius)) * 0.0625;   // Bottom-left
        color += image.Sample(textureSampler, uv + float2(-blur_radius, blur_radius)) * 0.0625;  // Top-left
        color += image.Sample(textureSampler, uv - float2(-blur_radius, blur_radius)) * 0.0625;  // Bottom-right
    } else {
        // Precise sampling for crisp scaling (no blur)
        color = image.Sample(textureSampler, uv);
    }

    // === SCANLINES EFFECT (CRT-ACCURATE ALTERNATING PATTERN) ===
    // scan_line_distance: height ratio of gap to scanline (0.0 = no gap, 0.5 = gap half as tall as scanline, 1.0 = gap same height as scanline)
    // scan_line_strength: darkness of the gap (0.0 = no darkness, 1.0 = completely black)
    if (scan_line_distance > 0.0 && scan_line_strength > 0.0) {
        // Calculate which row we're in within the scaled output
        float pixel_row = uv.y * output_height;

        // Fundamental fix: Every output pixel should alternate between scanline and gap
        // scan_line_distance controls gap WIDTH, not gap FREQUENCY
        // For ALL settings, pattern should be: S G S G S G (single scanline, single gap)

        // Simple integer-based approach: every 2nd pixel is a gap
        int pixel_index = int(pixel_row);
        bool is_even_pixel = (pixel_index % 2) == 0;

        if (!is_even_pixel) {
            // Odd pixels are gaps - darken them based on scan_line_distance
            // scan_line_distance controls how dark the gap is, not its frequency
            float gap_darkness = scan_line_distance * scan_line_strength;
            color.rgb *= (1.0 - gap_darkness);
        }
        // Even pixels remain bright (scanlines)
    }

    // === ENHANCED BLOOM EFFECT WITH BLEEDING ===
    if (bloom_strength > 0.0) {
        // Sample current pixel and neighbors for bloom bleeding effect
        float4 center = color;
        float bloom_radius = bloom_strength * 0.002; // Radius scales with strength

        // Multi-tap sampling for bloom bleeding - more taps = more bleeding at higher strength
        float4 bloom_sum = center * 0.4; // Center weight

        // Cross pattern sampling (4 directions)
        bloom_sum += image.Sample(textureSampler, uv + float2(bloom_radius, 0.0)) * 0.15;
        bloom_sum += image.Sample(textureSampler, uv - float2(bloom_radius, 0.0)) * 0.15;
        bloom_sum += image.Sample(textureSampler, uv + float2(0.0, bloom_radius)) * 0.15;
        bloom_sum += image.Sample(textureSampler, uv - float2(0.0, bloom_radius)) * 0.15;

        // Diagonal sampling for stronger bloom effect
        if (bloom_strength > 0.3) {
            bloom_sum += image.Sample(textureSampler, uv + float2(bloom_radius, bloom_radius) * 0.7) * 0.05;
            bloom_sum += image.Sample(textureSampler, uv + float2(-bloom_radius, bloom_radius) * 0.7) * 0.05;
            bloom_sum += image.Sample(textureSampler, uv + float2(bloom_radius, -bloom_radius) * 0.7) * 0.05;
            bloom_sum += image.Sample(textureSampler, uv + float2(-bloom_radius, -bloom_radius) * 0.7) * 0.05;
        }

        float brightness = dot(bloom_sum.rgb, float3(0.299, 0.587, 0.114));

        // Dynamic threshold that decreases as strength increases
        float threshold = 0.85 - (bloom_strength * 0.45);

        if (brightness > threshold) {
            // Calculate bloom factor based on how much we exceed threshold
            float bloom_factor = (brightness - threshold) / (1.0 - threshold);

            // ENHANCED: 7.5x stronger bloom
            float bloom_intensity = bloom_factor * (bloom_strength * 7.5);

            // Create bloom effect that preserves color saturation but bleeds
            float3 bloom_color = bloom_sum.rgb * (1.0 + bloom_intensity * 1.2);

            // Allow more oversaturation for stronger glow effect
            bloom_color = min(bloom_color, float3(1.5, 1.5, 1.5));

            // Blend with original color to create bleeding effect
            color.rgb = lerp(center.rgb, bloom_color, bloom_intensity * 0.8);
        } else {
            // Use the blended sample even without bloom for subtle bleeding
            color.rgb = lerp(center.rgb, bloom_sum.rgb, bloom_strength * 0.1);
        }
    }

    // === AFTERGLOW EFFECT ===
    // Temporal afterglow - blend with previous frame to create phosphor persistence
    if (afterglow_duration_ms > 0) {
        // Sample the previous frame at the same UV coordinate
        float4 prev_frame = texture_accum_prev.Sample(textureSampler, uv);

        // Calculate decay factor based on duration (frame-to-frame persistence)
        // Higher duration = slower decay = more persistent afterglow
        float decay_factor = 1.0 - (dt_ms / float(afterglow_duration_ms));
        decay_factor = max(0.0, min(0.95, decay_factor)); // Clamp to prevent infinite persistence

        // Apply decay curve to modify the decay behavior
        if (afterglow_curve == 1) { // Gradual Fade (Slow Start)
            decay_factor = decay_factor * decay_factor; // Quadratic - slower initial fade
        }
        else if (afterglow_curve == 2) { // Rapid Fade (Fast Start)
            decay_factor = sqrt(decay_factor); // Square root - faster initial fade
        }
        else if (afterglow_curve == 3) { // Long Tail (Exponential)
            decay_factor = pow(decay_factor, 0.5); // More persistent tail
        }
        // Linear (0) uses decay_factor as-is

        // Blend previous frame with current frame
        // Only non-black pixels from previous frame should contribute to afterglow
        float prev_brightness = dot(prev_frame.rgb, float3(0.299, 0.587, 0.114));
        if (prev_brightness > 0.01) { // Threshold to avoid amplifying pure black
            // Mix the previous frame's color with current color
            // This creates true temporal persistence - red→blue becomes red→purple→blue
            color.rgb = max(color.rgb, prev_frame.rgb * decay_factor);
        }
    }

    // === SCREEN TINT EFFECT ===
    // Emulate 1980s monochrome CRTs: first convert to monochrome, then apply tint
    if (tint_mode > 0 && tint_strength > 0.0) {
        // Step 1: Convert to monochrome (grayscale)
        float luminance = dot(color.rgb, float3(0.299, 0.587, 0.114));
        float3 monochrome = float3(luminance, luminance, luminance);

        // Step 2: Apply tint to the monochrome image
        float3 tinted_color = color.rgb;

        if (tint_mode == 1) { // Amber CRT
            float3 amber_tint = float3(1.0, 0.75, 0.3);
            tinted_color = lerp(color.rgb, monochrome * amber_tint, tint_strength);
        }
        else if (tint_mode == 2) { // Green CRT
            float3 green_tint = float3(0.5, 0.95, 0.35);
            tinted_color = lerp(color.rgb, monochrome * green_tint, tint_strength);
        }
        else if (tint_mode == 3) { // Pure Monochrome
            tinted_color = lerp(color.rgb, monochrome, tint_strength);
        }
        // tint_mode == 0 (None) - no change

        color.rgb = tinted_color;
    }

    return color;
}

technique Draw
{
    pass
    {
        vertex_shader = VSDefault(v_in);
        pixel_shader  = PSDefault(v_in);
    }
}
