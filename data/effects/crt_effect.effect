/*
C64 Stream - CRT Visual Effects Shader
Copyright (C) 2025 Christian Gleissner

Licensed under the GNU General Public License v2.0 or later.
See <https://www.gnu.org/licenses/> for details.
*/

// Uniforms
uniform float4x4 ViewProj;
uniform texture2d image;

// CRT effect parameters
uniform bool scanlines_enable;
uniform float scanlines_opacity;
uniform float pixel_width;
uniform float pixel_height;
uniform float blur_strength;
uniform bool bloom_enable;
uniform float bloom_strength;
uniform bool afterglow_enable;
uniform int afterglow_duration_ms;
uniform int afterglow_curve;
uniform bool tint_enable;
uniform int tint_mode;
uniform float tint_strength;
uniform float dt_ms;
uniform texture2d texture_accum_prev;

sampler_state textureSampler {
    Filter   = Linear;
    AddressU = Clamp;
    AddressV = Clamp;
};

struct VertData {
    float4 pos : POSITION;
    float2 uv  : TEXCOORD0;
};

VertData VSDefault(VertData v_in)
{
    VertData vert_out;
    vert_out.pos = mul(float4(v_in.pos.xyz, 1.0), ViewProj);
    vert_out.uv  = v_in.uv;
    return vert_out;
}

float4 PSDefault(VertData v_in) : TARGET
{
    float2 uv = v_in.uv;

    // === PIXEL GEOMETRY WITH BLUR CONTROL ===
    // Pixel geometry scaling is handled by get_width/get_height functions
    // Here we apply blur control for crisp vs soft scaling
    float4 color;
    if (blur_strength > 0.0) {
        // Gaussian-style blur with multiple taps for soft scaling
        float blur_radius = blur_strength * 0.003; // Increased for more visible effect

        // 9-tap gaussian-style sampling
        color  = image.Sample(textureSampler, uv) * 0.25;                                    // Center (main weight)
        color += image.Sample(textureSampler, uv + float2(blur_radius, 0.0)) * 0.125;       // Right
        color += image.Sample(textureSampler, uv - float2(blur_radius, 0.0)) * 0.125;       // Left
        color += image.Sample(textureSampler, uv + float2(0.0, blur_radius)) * 0.125;       // Up
        color += image.Sample(textureSampler, uv - float2(0.0, blur_radius)) * 0.125;       // Down
        color += image.Sample(textureSampler, uv + float2(blur_radius, blur_radius)) * 0.0625;   // Top-right
        color += image.Sample(textureSampler, uv - float2(blur_radius, blur_radius)) * 0.0625;   // Bottom-left
        color += image.Sample(textureSampler, uv + float2(-blur_radius, blur_radius)) * 0.0625;  // Top-left
        color += image.Sample(textureSampler, uv - float2(-blur_radius, blur_radius)) * 0.0625;  // Bottom-right
    } else {
        // Precise sampling for crisp scaling (no blur)
        color = image.Sample(textureSampler, uv);
    }

    // === SCANLINES EFFECT (EARLY APPLICATION) ===
    // Apply scanlines early so other effects can bleed into them for authentic CRT look
    if (scanlines_enable) {
        // When scanlines are enabled, frame is scaled 2x in both dimensions
        // Odd-numbered rows (1, 3, 5, etc.) are duplicates of even rows but darker
        float scaled_y = uv.y * 2.0 * pixel_height; // Scale by 2x for scanlines + pixel geometry
        int row_index = int(floor(scaled_y));

        // Check if this is an odd-numbered row (scanline row)
        if ((row_index % 2) == 1) {
            // This is a scanline row (odd index) - apply darkness
            // scanlines_opacity controls how dark the line is:
            // 0.0 = completely black, 1.0 = same brightness as original
            color.rgb *= scanlines_opacity;
        }
        // Even rows (0, 2, 4, etc.) remain unchanged (original brightness)
    }

    // === ENHANCED BLOOM EFFECT WITH BLEEDING ===
    if (bloom_enable) {
        // Sample current pixel and neighbors for bloom bleeding effect
        float4 center = color;
        float bloom_radius = bloom_strength * 0.002; // Radius scales with strength

        // Multi-tap sampling for bloom bleeding - more taps = more bleeding at higher strength
        float4 bloom_sum = center * 0.4; // Center weight

        // Cross pattern sampling (4 directions)
        bloom_sum += image.Sample(textureSampler, uv + float2(bloom_radius, 0.0)) * 0.15;
        bloom_sum += image.Sample(textureSampler, uv - float2(bloom_radius, 0.0)) * 0.15;
        bloom_sum += image.Sample(textureSampler, uv + float2(0.0, bloom_radius)) * 0.15;
        bloom_sum += image.Sample(textureSampler, uv - float2(0.0, bloom_radius)) * 0.15;

        // Diagonal sampling for stronger bloom effect
        if (bloom_strength > 0.3) {
            bloom_sum += image.Sample(textureSampler, uv + float2(bloom_radius, bloom_radius) * 0.7) * 0.05;
            bloom_sum += image.Sample(textureSampler, uv + float2(-bloom_radius, bloom_radius) * 0.7) * 0.05;
            bloom_sum += image.Sample(textureSampler, uv + float2(bloom_radius, -bloom_radius) * 0.7) * 0.05;
            bloom_sum += image.Sample(textureSampler, uv + float2(-bloom_radius, -bloom_radius) * 0.7) * 0.05;
        }

        float brightness = dot(bloom_sum.rgb, float3(0.299, 0.587, 0.114));

        // Dynamic threshold that decreases as strength increases
        float threshold = 0.85 - (bloom_strength * 0.45);

        if (brightness > threshold) {
            // Calculate bloom factor based on how much we exceed threshold
            float bloom_factor = (brightness - threshold) / (1.0 - threshold);

            // ENHANCED: 3x stronger bloom (7.5x instead of 2.5x)
            float bloom_intensity = bloom_factor * (bloom_strength * 7.5);

            // Create bloom effect that preserves color saturation but bleeds
            float3 bloom_color = bloom_sum.rgb * (1.0 + bloom_intensity * 1.2);

            // Allow more oversaturation for stronger glow effect
            bloom_color = min(bloom_color, float3(1.5, 1.5, 1.5));

            // Blend with original color to create bleeding effect
            color.rgb = lerp(center.rgb, bloom_color, bloom_intensity * 0.8);
        } else {
            // Use the blended sample even without bloom for subtle bleeding
            color.rgb = lerp(center.rgb, bloom_sum.rgb, bloom_strength * 0.1);
        }
    }

    // === AFTERGLOW EFFECT ===
    // Temporal afterglow - blend with previous frame to create phosphor persistence
    if (afterglow_enable && afterglow_duration_ms > 0) {
        // Sample the previous frame at the same UV coordinate
        float4 prev_frame = texture_accum_prev.Sample(textureSampler, uv);

        // Calculate decay factor based on duration (frame-to-frame persistence)
        // Higher duration = slower decay = more persistent afterglow
        float decay_factor = 1.0 - (dt_ms / float(afterglow_duration_ms));
        decay_factor = max(0.0, min(0.95, decay_factor)); // Clamp to prevent infinite persistence

        // Apply decay curve to modify the decay behavior
        if (afterglow_curve == 1) { // Gradual Fade (Slow Start)
            decay_factor = decay_factor * decay_factor; // Quadratic - slower initial fade
        }
        else if (afterglow_curve == 2) { // Rapid Fade (Fast Start)
            decay_factor = sqrt(decay_factor); // Square root - faster initial fade
        }
        else if (afterglow_curve == 3) { // Long Tail (Exponential)
            decay_factor = pow(decay_factor, 0.5); // More persistent tail
        }
        // Linear (0) uses decay_factor as-is

        // Blend previous frame with current frame
        // Only non-black pixels from previous frame should contribute to afterglow
        float prev_brightness = dot(prev_frame.rgb, float3(0.299, 0.587, 0.114));
        if (prev_brightness > 0.01) { // Threshold to avoid amplifying pure black
            // Mix the previous frame's color with current color
            // This creates true temporal persistence - red→blue becomes red→purple→blue
            color.rgb = max(color.rgb, prev_frame.rgb * decay_factor);
        }
    }

    // === SCREEN TINT EFFECT ===
    // Emulate 1980s monochrome CRTs: first convert to monochrome, then apply tint
    if (tint_enable && tint_strength > 0.0) {
        // Step 1: Convert to monochrome (grayscale)
        float luminance = dot(color.rgb, float3(0.299, 0.587, 0.114));
        float3 monochrome = float3(luminance, luminance, luminance);

        // Step 2: Apply tint to the monochrome image
        float3 tinted_color = color.rgb;

        if (tint_mode == 1) { // Amber CRT
            float3 amber_tint = float3(1.0, 0.75, 0.3);
            tinted_color = lerp(color.rgb, monochrome * amber_tint, tint_strength);
        }
        else if (tint_mode == 2) { // Green CRT
            float3 green_tint = float3(0.5, 0.95, 0.35);
            tinted_color = lerp(color.rgb, monochrome * green_tint, tint_strength);
        }
        else if (tint_mode == 3) { // Pure Monochrome
            tinted_color = lerp(color.rgb, monochrome, tint_strength);
        }
        // tint_mode == 0 (None) - no change

        color.rgb = tinted_color;
    }

    return color;
}

technique Draw
{
    pass
    {
        vertex_shader = VSDefault(v_in);
        pixel_shader  = PSDefault(v_in);
    }
}
